\subsection{Overview}
The DSL is divided into two components, a arithmetic expression language(Formula Expression
Language) and language specifying a web site and additionally specifying input sources for
the system. 
The expression language is a utility language which is included by the other language. 
The arithmetic expression language defines how a user can create arithmetic expressions in
either of the other two languages. 
The Web visualizer is a language to create dynamic web sites, like the sample page shown on Figure \ref{fig:frontpage}.

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{images/frontpage}
  \end{center}
  \caption{Example page generated by the DSL}
  \label{fig:frontpage}
\end{figure}

\subsection{The Formula Expression Language}
The Formula Expressions language is responsible for understanding mathematical formulas,
which will be applied to single arrays of data.
\paragraph{Meta model}

The formula metamodel consist of multiple elements, an overview is seen in Figure
\ref{fig:formulaModel}. The types included in the elements in the model are is explained as below:
\begin{enumerate}
\item Formula: The overall Structure Element
\item Variable: The variable names included in the formula, appears both left and right side of the equation
\item Expression: The right side of the equal sign in a formula. The Expression collects the parts which is connected with plus($+$) and minus($-$). 
\item Factor: A semi-structure of the expression, Factors collects the parts connected with multiplication($\cdot$) and division($/$).
\item Op1: Identifies a addition or substraction operation
\item Op2: Identifies a multiplication or divison a operation
\item Primitiv: Identifies as either a number or a Variable
\end{enumerate}

\begin{figure}
  \begin{center}
    \includegraphics[width=\linewidth]{images/formulaInstance}
  \end{center}
  \caption{Instance of Formula}
  \label{fig:formulaInstance}
\end{figure}

Given the following the example: $$f(x, y) = 5 + x \cdot 3 - y$$
The rules for the grammar is explained as below also referring to
Figure \ref{fig:formulaInstance}:
\\
A Formula Contains a name which is defined as the letter/word in front of the paranthesis
also underlined in the following formula: $\underline{f}(x, y) = 5 + x \cdot 3 - y$.
In Figure \ref{fig:formulaInstance} ``f'' is defined as ``name'' seen as an attribute
for the overall Formula.
It also contains a list of variables, defined within the paranthesis seperated
by ``,'' as underlined: $f\underline{(x, y)} = 5 + x \cdot 3 - y$. The variables is saved
as a list under formula as ``vars'' seen at List of Variables.
Finally the expression of the formula is everything on the right side of the equal-sign(``=''),
here follows the rule that every variable used in the expression has to appear inside
the paranthesis on the left side of the formula as well, as it works as a function,
the expression part underlined: $f(x, y) = \underline{5 + x \cdot 3 - y}$ refered to
as ``exp'' and seen as ``expression1'' in Figure \ref{fig:formulaInstance}. 

Looking at the expression(``expression1''): $5 + x \cdot 3 - y$ it is broken down by continouisly
working from the left to the right. the left part of the expression is defined as a factor until
it meets an addition or substraction sign. For the formula example this would put only the number
``5'' into the left side factor as ``factor1'' in Figure \ref{fig:formulaInstance},
futher containing ``5'' in the Number object ``n1''.
Expression2 is then the rest of the equation after $5 +$. The new expression
contains again one factor which is the left side($x \cdot 3$) seperated by the substraction sign
The factor ``factor2'' contains on the left ``var1'' which is x, and on the right another factor
is spawned seen as ``factor3'' in Figure \ref{fig:formulaInstance}, only containing a left
side being the number seen in ``n2'' as 3.
Coming back up to the expression. it contains the last part of y as ``expression3''
which only a left side being a factor(factor4) and that factor also only contains a left side
which is the variable ``var2'' being the y.

For the variables ``var1'' and ``var2'', both is included in the List of Variables in as seen in
Figure \ref{fig:formulaInstance}


\begin{figure}
  \begin{center}
  \includegraphics[width=\linewidth]{images/MetaFormula}
  \end{center}
  \caption{Model of the formula module}
  \label{fig:formulaModel}
\end{figure}
\paragraph{Language Validation}
has been archieved partly by the BNF\footnote{\cite{BNF}} using Xtext, but also
using Xtend to write additional validation code, where the Xtext language was not sufficient
to validate that the structure did indeed not violate any rules.

Xtext could only validate the general structure of the model.
what xtext was not archieved was to have xtext validate that the only variables used
on the right side og the equation sign was declared on the left side.
In order to validate that the variables on the right was declared on the left a
collection containing the declared variables on the left was matches against all the variables
on the right fetched using recursion with depth first search.

\subsection{The Web visualizer Language}
For generating dashboards a custom language have been created.
The language specify:
\begin{itemize}
\item Which pages the web-interface contains
\item The navigation between pages
\item Which data to display and which page displays which data
\item Where and how to obtain the data
\subitem Internal data streams
\subitem External data streams
\item How to manipulate the data streams using formulas
\end{itemize}
The following subsection will look into detail of how the language is structured and the
syntax and grammar of the language.

\subparagraph{The Grammar}
\begin{figure}
\begin{center}
\includegraphics[width=\linewidth]{images/languagemodel}
\end{center}
\caption{Model of the language}
\label{fig:languagemodel}
\end{figure}
Figure \ref{fig:languagemodel} shows the structure of the language.
This model shows that the language defines of a system containing three parts:
\begin{itemize}
\item Pages
\item Sources
\item Schemas
\end{itemize}

\textbf{The Pages,} is what the language in turns will use to create web pages in a system
defined in the language.
A page is a collection of tiles. 
Each tile is an extendible definition of a visual object on a page.
In the current version, there are two types of Tiles, Links and Graphs.
A Link definition contains a pointer to a page. 
A Graph however, has a reference data \textit{source} from which it fetches data from.
\begin{figure}
\begin{center}
\lstinputlisting[language=Java, frame=single, breaklines=true,tabsize=3]{code/GrammaDefinition.xtext}
\end{center}
\caption{Sample grammar definition, For a complete view of the grammar, see Appendix }
\label{fig:grammadefinition}
\end{figure}
Figure \ref{fig:grammadefinition} shows a sample code snippet from the grammar definition.
The Figure shows how the grammar is defined for the Pages, Tiles, Links and Graphs.
Similar does Figure \ref{fig:examplePages} show and example use of this grammar. 
This example creates a system object with two pages interconnected by links and with a number
of graphs.
\begin{figure}
\begin{center}
\lstinputlisting[language=Java, frame=single, breaklines=true,tabsize=3]{code/ExampleUsePages.vis}
\end{center}
\caption{Example language use, defining pages}
\label{fig:examplePages}
\end{figure}

\textbf{The Sources, } can be of two different types, an \textit{EndPoint} or a \textit{DataSource}.
An EndPoint is intended to function as interface between external systems and data sources. 
Where as a Datasource is an internal definition intended for filtering, data manipulation or
data grouping.\\
These Source, Endpoint, Datasource-Dimension structure have been defined as a compositional
pattern, with source as the component, the Endpoint functions as a leaf and
the Datasource as the composite.
This pattern makes it possible to compose any number of different sources.
In addition every defined dimension comes with a formula, which will be applied to the data.
A Source can have multiple dimensions (data streams). When specifying how a Source,
Dimension-selectors can be specified to select subset of the dimensions from a refering source.
Figure \ref{fig:exampleDatasources} shows and example of a Datasource created through the
language. 
The first line creates a Datasource and when declares a list of dimensions. 
Each declaration of a dimension starts by declaring a formula. After the formula follows a
declaration of Sources used in the formula. 

\begin{figure}
\begin{center}
\lstinputlisting[language=Java, frame=single, breaklines=true,tabsize=3]{code/ExampleUseDataSources.vis}
\end{center}
\caption{Example language use, defining data sources}
\label{fig:exampleDatasources}
\end{figure}

Figure \ref{fig:exampleEndpoints} is an example of the use of Endpoints.
In the example, a GetEndPoint is created. This Endpoint type contains a url, a list of headers
and a schema parser.
In addition this can contain a payload field used for POST request returning data, like for
instance the query language of the SMap system.
\begin{figure}
\begin{center}
\lstinputlisting[language=Java, frame=single, breaklines=true,tabsize=3]{code/ExampleUseEndPoint.vis}
\end{center}
\caption{Example language use, defining endpoints}
\label{fig:exampleEndpoints}
\end{figure}

\textbf{The Schemas,} or SchemaParsers are a global way of defining how to parse date from an
EndPoint.
This is both needed when defining an source to request data from and when external sources posts
data to the system.

\paragraph{Meta model}
The language compiles a dynamic website using the Django framework.
This framework uses an MVC architektur which is extended with a template pattern with
HTML documents. 
In order to make the output easy readable and customizable for a user the output needs to be
mapped into a model that follows this pattern with more explicit information.

In order to do so, a meta model of the a website using this framework have been created which
incorporates the functionality of the desired dashboard system.  
Figure \ref{fig:websitemodel} shows this meta model.
This meta model differs in a number of ways from the model created by the language.
This is due to the high complexity of the Django framework.
In order to keep the language simple it was decided to create a simpler model for the language
(see Figure \ref{fig:languagemodel}) and map this model to the created meta model of the system.
The meta model however have adopted some aspects of the language model, like for instance
the part concerning Datasources, Endpoints, parsers and selectors.
 
To follow the convention of MVC pattern in django framework the constructed pages and
content needs to be mapped properly. First define a controller in form of url files containing
the mapping of urls to either views of the system or other urls files.
The views can either use a model and/or a HTML template file to build up the responses for a
request with the use of a number of serializables.

\begin{figure}
\begin{center}
\includegraphics[width=\linewidth]{images/websitemodel}
\end{center}
\caption{Model of the Website}
\label{fig:websitemodel}
\end{figure}

\paragraph{Language Validation}
of the entire vizualizer project containing validating the following items:
\begin{enumerate}
\item \textbf{[XText]} The page linked to from one page to another existed
\item \textbf{[XText]} Graphs contains an existing reference to a Datasource
\item \textbf{[XText]} GetEndPoints contains a Schema
\item \textbf{[XText]} Schemas contain at least 1 Selector
\item \textbf{[XText]} Datasources contains at least one Dimension
\item \textbf{[XText]} Dimension contains at least one reference to a Source
\item \textbf{[XTend]} Datasources have no cyclic dependencies
\item \textbf{[XTend]} All the variables declared on the left side of a formula is also declared under one of the DimensionSelectors listed for that Dimension.
\item \textbf{[XTend]} All Datasources is directly or indirectly connected to an EndPoint
\end{enumerate}

It was not archieved to validate all the rules in the grammar strictly using XText and a few
of the rules had to be checked in the syntax tree. XText can make checks like that a reference is
existing and that the overall grammar structure is correct.
The things that XTend can do is that after the initial grammar, the instance of the grammar is
built and that gives some additional possibilities to validate the program from XTend. Here
only the full validation should be possible, given that the language is not turing
complete\footnote{make ref to turing completeness}. As listed previously cyclic dependencies
can be checked a long with more advanced type checking. Maybe a language would contain an odd
rule that the number 5 would not be allowed. This could be put into the XText document,
but would be much easier to validate using XTend. Here we could also extend the Formula projects
language validation rules within the Vizualizer language futher using XTend by checking that
declared variables on the left side of a formula was supported by a declared variable from
a DimensionSelector. 

\paragraph{Code generation}
To maintain a somewhat clean code structure all generated code are put into a number of different
packages, see Figure \ref{fig:packagediagram}.
This diagram shows the structure of the generated code.
\begin{figure}
\begin{center}
\includegraphics[width=\linewidth]{images/PackageDiagram}
\end{center}
\caption{Package diagram of generated sources}
\label{fig:packagediagram}
\end{figure}
The ``DataHandle'' package contains all code for handling the obtaining of data from external
systems. 
Inside the ``DataHandle'' package the data sources, endpoints selectors and schema parsers are
generated.
The api package contains the code generated for creating a API for external sources to post data.
The package contain models, views, serializes and a controller for the API.
A page object from the language model is split into a number of fractions.
A page needs to be divided into a model a view, a controller and a HTML template document.
To better keep things apart the template documents have been gathered in a package by itself (the template package).
The model, views and controllers are generated into the pages package.
Each page gets it own template file extending a base template file making them easy customizable.
The individual template file contains only the structure of the specific links and graphs (without data) of that page.

Figure \ref{fig:codegen} shows the work flow of this code generation.
\begin{figure}
\begin{center}
\includegraphics[width=\linewidth]{images/codegeneration}
\end{center}
\caption{The work flow of the code generation}
\label{fig:codegen}
\end{figure}
The code generation starts with pre-compiling all the web-server files and settings,
including the settings.py file and the base urls.py file.
Both the settings and the base urls file are generated to include the web dashboard application
generated by the rest of the code generation sequence.
Next the api generation sequence is started. When fully implemented it will generate the model,
views, serializables and controllers needed.
After this, is the data handling sequence is initiated. In this sequence all the endpoints and
data sources are build and configured.
The third sequence is the template html file generation initiated. Here all template documents
are build and configured to use the base template theme and visualization.
After building all elements regarding system configuration, data handling and visualization the
final sequence (post generation) is initiated.
This sequence builds the views and urls that binds everything to the web-server.

\subparagraph{Generation}
The code generation have been done through the [XTend] language.
This language provides some additional coding features not avaialble in plain Java.
One of the highly used features is the multi dispatching also known as the polymorphic
method invocation.
When multi dispatching the method selected for invocation is the method with the most
specialized parameter for a given type. 
Meaning if many extension methods are created for classes in a extension hierarchy the multi
dispatching will invoke the method based on the sub class type and not the super class.
Figure \ref{fig:multidispatching} how formulas are generated using multi dispatching in a
nested loop.
The snippet shows four dispatch methods with same name taking different parameters.
Calling the traversal algorithm with a expression from a formula will cause the algorithm to
traverse through the entire tree of expressions, factors, variables and numbers where it will
treat every different sub type of the "primitive" type differently.

\begin{figure}
\begin{center}
\lstinputlisting[language=Java, frame=single, breaklines=true,tabsize=3]{code/multidispatch.java}
\end{center}
\caption{Code generation with multi dispatching}
\label{fig:multidispatching}
\end{figure}
