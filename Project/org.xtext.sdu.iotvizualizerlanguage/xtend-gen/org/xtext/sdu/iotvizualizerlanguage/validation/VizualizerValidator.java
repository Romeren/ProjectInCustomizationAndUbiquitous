/**
 * generated by Xtext 2.9.2
 */
package org.xtext.sdu.iotvizualizerlanguage.validation;

import java.util.Arrays;
import java.util.List;
import javax.xml.ws.Endpoint;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.xtext.sdu.formularzlanguage.formular.Formula;
import org.xtext.sdu.formularzlanguage.formular.Variable;
import org.xtext.sdu.iotvizualizerlanguage.validation.AbstractVizualizerValidator;
import org.xtext.sdu.iotvizualizerlanguage.vizualizer.Datasource;
import org.xtext.sdu.iotvizualizerlanguage.vizualizer.Dimension;
import org.xtext.sdu.iotvizualizerlanguage.vizualizer.DimensionSelector;
import org.xtext.sdu.iotvizualizerlanguage.vizualizer.NoQuotesString;
import org.xtext.sdu.iotvizualizerlanguage.vizualizer.Source;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class VizualizerValidator extends AbstractVizualizerValidator {
  @Check
  public void checkFormulaForSourceVariable(final Dimension checkedDimension) {
    Formula _name = checkedDimension.getName();
    EList<Variable> _vars = _name.getVars();
    for (final Variable param : _vars) {
      EList<DimensionSelector> _sourceSelectors = checkedDimension.getSourceSelectors();
      final Function1<DimensionSelector, String> _function = (DimensionSelector selector) -> {
        return selector.getName();
      };
      List<String> _map = ListExtensions.<DimensionSelector, String>map(_sourceSelectors, _function);
      String _name_1 = param.getName();
      boolean _contains = _map.contains(_name_1);
      boolean _not = (!_contains);
      if (_not) {
        EClass _eClass = param.eClass();
        EStructuralFeature _eStructuralFeature = _eClass.getEStructuralFeature(0);
        this.error("You should not Have done that. You will get in trouble!", param, _eStructuralFeature);
      }
    }
  }
  
  @Check
  public void checkSourceHasDimension(final DimensionSelector dimensionSelector) {
    Source _source = dimensionSelector.getSource();
    NoQuotesString _selectVar = dimensionSelector.getSelectVar();
    String _name = _selectVar.getName();
    boolean _hasDimension = this.hasDimension(_source, _name);
    boolean _not = (!_hasDimension);
    if (_not) {
      NoQuotesString _selectVar_1 = dimensionSelector.getSelectVar();
      NoQuotesString _selectVar_2 = dimensionSelector.getSelectVar();
      EClass _eClass = _selectVar_2.eClass();
      EStructuralFeature _eStructuralFeature = _eClass.getEStructuralFeature(0);
      this.error("Source does not contain the dimensional Variable you are refering to", _selectVar_1, _eStructuralFeature);
    }
  }
  
  @Check
  protected boolean _hasDimension(final Endpoint endpoint, final String id) {
    return true;
  }
  
  @Check
  protected boolean _hasDimension(final Datasource datasource, final String id) {
    EList<Dimension> _dimensions = datasource.getDimensions();
    final Function1<Dimension, String> _function = (Dimension dimension) -> {
      Formula _name = dimension.getName();
      return _name.getName();
    };
    List<String> _map = ListExtensions.<Dimension, String>map(_dimensions, _function);
    return _map.contains(id);
  }
  
  public boolean hasDimension(final Object datasource, final String id) {
    if (datasource instanceof Datasource) {
      return _hasDimension((Datasource)datasource, id);
    } else if (datasource instanceof Endpoint) {
      return _hasDimension((Endpoint)datasource, id);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(datasource, id).toString());
    }
  }
}
